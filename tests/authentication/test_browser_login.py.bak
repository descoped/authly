"""
Browser-based login flow tests.

Tests the /auth/login endpoint and form-based authentication
that enables OAuth authorization flows using real database and services.
"""

from uuid import uuid4

import pytest
from fastapi import status
from psycopg_toolkit import TransactionManager

from authly.core.resource_manager import AuthlyResourceManager
from authly.users import UserRepository
from authly.users.service import UserService


class TestBrowserLoginPage:
    """Test the login page rendering with real application."""

    @pytest.mark.asyncio
    async def test_login_page_renders_correctly(self, test_server):
        """Test that the login page renders with all required elements."""
        async with test_server.client as client:
            response = await client.get("/auth/login")
            assert response.status_code == status.HTTP_200_OK
            # AsyncTestResponse wraps httpx.Response - access headers through _response
            assert "text/html" in response._response.headers.get("content-type", "")

            # Check for essential form elements
            content = response.text
            assert '<form' in content
            assert 'name="username"' in content or 'name="email"' in content
            assert 'name="password"' in content
            assert 'type="submit"' in content

    @pytest.mark.asyncio
    async def test_login_page_with_redirect_param(self, test_server):
        """Test login page preserves redirect_to parameter."""
        async with test_server.client as client:
            redirect_url = "/api/v1/oauth/authorize?client_id=test"
            response = await client.get(f"/auth/login?redirect_to={redirect_url}")
            assert response.status_code == status.HTTP_200_OK

            content = response.text
            # The redirect URL should be preserved in the form
            assert 'redirect_to' in content

    @pytest.mark.asyncio
    async def test_login_page_shows_error_message(self, test_server):
        """Test login page displays error messages."""
        async with test_server.client as client:
            response = await client.get("/auth/login?error=invalid_credentials")
            assert response.status_code == status.HTTP_200_OK

            content = response.text
            assert 'invalid' in content.lower() or 'error' in content.lower()


class TestBrowserLoginSubmission:
    """Test the login form submission with real user data."""

    @pytest.mark.asyncio
    async def test_login_with_valid_credentials(
        self,
        test_server,
        initialize_authly: AuthlyResourceManager,
        transaction_manager: TransactionManager
    ):
        """Test successful login with valid credentials using real database."""
        async with test_server.client as client, transaction_manager.transaction() as conn:
            user_repo = UserRepository(conn)
            user_service = UserService(user_repo)

            # Create a real test user
            username = f"testuser_{uuid4().hex[:8]}"
            password = "TestPassword123!"

            user_data = {
                "username": username,
                "email": f"{username}@example.com",
                "password": password,
                "is_active": True,
                "is_verified": True,
            }

            created_user = await user_service.create_user(user_data)
            assert created_user is not None

            # Get CSRF token from login page
            login_page = await client.get("/auth/login")
            assert login_page.status_code == status.HTTP_200_OK

            # Extract CSRF token from response (if implemented)
            # For now, we'll use a placeholder
            csrf_token = "test_csrf_token"

            # Attempt login with real credentials
            response = await client.post(
                "/auth/login",
                data={
                    "username": username,
                    "password": password,
                    "csrf_token": csrf_token
                },
                follow_redirects=False
            )

            # Should redirect after successful login
            assert response.status_code in [status.HTTP_302_FOUND, status.HTTP_303_SEE_OTHER]

            # Should set session cookie
            cookies = response.headers.get("set-cookie", "")
            assert "authly_session" in cookies or "session" in cookies

    @pytest.mark.asyncio
    async def test_login_with_invalid_credentials(
        self,
        test_server,
        initialize_authly: AuthlyResourceManager
    ):
        """Test login failure with invalid credentials."""
        response = await client.post(
            "/auth/login",
            data={
                "username": "nonexistent_user",
                "password": "wrongpassword",
                "csrf_token": "test_csrf_token"
            },
            follow_redirects=False
        )

        # Should either redirect with error or return error status
        if response.status_code in [status.HTTP_302_FOUND, status.HTTP_303_SEE_OTHER]:
            location = response.headers.get("location", "")
            assert "error" in location or "login" in location
        else:
            assert response.status_code in [status.HTTP_400_BAD_REQUEST, status.HTTP_401_UNAUTHORIZED]

    @pytest.mark.asyncio
    async def test_login_missing_credentials(self, test_server):
        """Test login with missing credentials."""
        response = await client.post(
            "/auth/login",
            data={"username": "testuser"},  # Missing password
            follow_redirects=False
        )

        assert response.status_code in [
            status.HTTP_400_BAD_REQUEST,
            status.HTTP_422_UNPROCESSABLE_ENTITY
        ]

    @pytest.mark.asyncio
    async def test_login_redirect_after_success(
        self,
        test_server,
        initialize_authly: AuthlyResourceManager,
        transaction_manager: TransactionManager
    ):
        """Test redirect to original URL after successful login."""
        async with transaction_manager.transaction() as conn:
            user_repo = UserRepository(conn)
            user_service = UserService(user_repo)

            # Create test user
            username = f"testuser_{uuid4().hex[:8]}"
            password = "TestPassword123!"

            await user_service.create_user({
                "username": username,
                "email": f"{username}@example.com",
                "password": password,
                "is_active": True,
                "is_verified": True,
            })

            redirect_url = "/api/v1/oauth/authorize?client_id=test"

            response = await client.post(
                "/auth/login",
                data={
                    "username": username,
                    "password": password,
                    "redirect_to": redirect_url,
                    "csrf_token": "test_csrf_token"
                },
                follow_redirects=False
            )

            assert response.status_code in [status.HTTP_302_FOUND, status.HTTP_303_SEE_OTHER]
            location = response.headers.get("location", "")
            # Should redirect to the requested URL or at least contain 'authorize'
            assert "authorize" in location or redirect_url in location


class TestBrowserLoginRateLimiting:
    """Test rate limiting on login attempts."""

    @pytest.mark.asyncio
    async def test_login_rate_limiting(
        self,
        test_server,
        initialize_authly: AuthlyResourceManager
    ):
        """Test that rate limiting is applied after multiple failed attempts."""
        username = f"testuser_{uuid4().hex[:8]}"

        # Make multiple failed login attempts
        responses = []
        for i in range(10):
            response = await client.post(
                "/auth/login",
                data={
                    "username": username,
                    "password": f"wrongpassword{i}",
                    "csrf_token": "test_csrf_token"
                },
                follow_redirects=False
            )
            responses.append(response)

        # Check if any response indicates rate limiting
        status_codes = [r.status_code for r in responses]

        # Should eventually get rate limited or require additional verification
        # Look for 429 (Too Many Requests) or redirects with rate limit errors
        rate_limited = any(
            code == status.HTTP_429_TOO_MANY_REQUESTS for code in status_codes
        )

        if not rate_limited:
            # Check if later responses have different behavior (e.g., captcha requirement)
            last_response = responses[-1]
            if last_response.status_code in [status.HTTP_302_FOUND, status.HTTP_303_SEE_OTHER]:
                location = last_response.headers.get("location", "")
                # Might redirect to captcha or rate limit page
                rate_limited = "rate" in location.lower() or "captcha" in location.lower()

        # Note: Rate limiting might not be implemented yet
        # This test documents expected behavior


class TestBrowserLoginSession:
    """Test session management after login with real backend."""

    @pytest.mark.asyncio
    async def test_login_session_creation(
        self,
        test_server,
        initialize_authly: AuthlyResourceManager,
        transaction_manager: TransactionManager
    ):
        """Test that a session is created after successful login."""
        async with transaction_manager.transaction() as conn:
            user_repo = UserRepository(conn)
            user_service = UserService(user_repo)

            # Create test user
            username = f"testuser_{uuid4().hex[:8]}"
            password = "TestPassword123!"

            await user_service.create_user({
                "username": username,
                "email": f"{username}@example.com",
                "password": password,
                "is_active": True,
                "is_verified": True,
            })

            response = await client.post(
                "/auth/login",
                data={
                    "username": username,
                    "password": password,
                    "csrf_token": "test_csrf_token"
                },
                follow_redirects=False
            )

            # Verify session cookie is set
            cookies = response.headers.get("set-cookie", "")
            assert cookies

            # Cookie should have secure attributes
            cookie_lower = cookies.lower()
            assert "httponly" in cookie_lower
            assert "samesite" in cookie_lower

    @pytest.mark.asyncio
    async def test_session_persists_across_requests(
        self,
        test_server,
        initialize_authly: AuthlyResourceManager,
        transaction_manager: TransactionManager
    ):
        """Test that session persists across multiple requests."""
        async with transaction_manager.transaction() as conn:
            user_repo = UserRepository(conn)
            user_service = UserService(user_repo)

            # Create test user
            username = f"testuser_{uuid4().hex[:8]}"
            password = "TestPassword123!"

            await user_service.create_user({
                "username": username,
                "email": f"{username}@example.com",
                "password": password,
                "is_active": True,
                "is_verified": True,
            })

            # Login
            login_response = await client.post(
                "/auth/login",
                data={
                    "username": username,
                    "password": password,
                    "csrf_token": "test_csrf_token"
                },
                follow_redirects=False
            )

            # Extract session cookie
            cookies = login_response.cookies

            # Use session to access protected endpoint
            session_response = await client.get(
                "/auth/session",
                cookies=cookies
            )

            # Should be authenticated
            if session_response.status_code == status.HTTP_200_OK:
                data = session_response.json()
                assert "user_id" in data or "username" in data


class TestBrowserLoginIntegration:
    """Integration tests for login flow with OAuth."""

    @pytest.mark.asyncio
    async def test_login_to_oauth_flow(
        self,
        test_server,
        initialize_authly: AuthlyResourceManager,
        transaction_manager: TransactionManager
    ):
        """Test complete flow from login to OAuth authorization."""
        async with transaction_manager.transaction() as conn:
            from authly.oauth.client_repository import ClientRepository
            from authly.oauth.models import ClientType, TokenEndpointAuthMethod

            user_repo = UserRepository(conn)
            user_service = UserService(user_repo)
            client_repo = ClientRepository(conn)

            # Create test user
            username = f"testuser_{uuid4().hex[:8]}"
            password = "TestPassword123!"

            await user_service.create_user({
                "username": username,
                "email": f"{username}@example.com",
                "password": password,
                "is_active": True,
                "is_verified": True,
            })

            # Create test OAuth client
            client_id = f"test_client_{uuid4().hex[:8]}"
            client = await client_repo.create_client({
                "client_id": client_id,
                "client_name": "Test Client",
                "client_type": ClientType.PUBLIC,
                "redirect_uris": ["http://localhost/callback"],
                "require_pkce": True,
                "token_endpoint_auth_method": TokenEndpointAuthMethod.NONE,
            })

            # Step 1: Try to access OAuth authorize endpoint (should redirect to login)
            oauth_url = f"/api/v1/oauth/authorize?client_id={client_id}&response_type=code&redirect_uri=http://localhost/callback&code_challenge=test&code_challenge_method=S256"

            auth_response = await client.get(oauth_url, follow_redirects=False)

            # Should redirect to login or return login_required error
            assert auth_response.status_code in [status.HTTP_302_FOUND, status.HTTP_303_SEE_OTHER]

            async with test_server.client as client:
                # Step 2: Login
                login_response = await client.post(
                    "/auth/login",
                    data={
                        "username": username,
                        "password": password,
                        "redirect_to": oauth_url,
                        "csrf_token": "test_csrf_token"
                    },
                    follow_redirects=False
                )

                # Should redirect after login
                assert login_response.status_code in [status.HTTP_302_FOUND, status.HTTP_303_SEE_OTHER]

                # Extract session cookie
                cookies = login_response.cookies

                # Step 3: Access OAuth with session cookie
                auth_with_session = await client.get(oauth_url, cookies=cookies)

                # Should now either show authorization page or process the request
                # Status depends on whether auto-approval is enabled
                assert auth_with_session.status_code in [
                    status.HTTP_200_OK,  # Shows consent form
                    status.HTTP_302_FOUND,  # Auto-approved and redirected
                    status.HTTP_303_SEE_OTHER  # Auto-approved and redirected
                ]

